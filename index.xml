<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>HOME on Danilo Pianini</title>
    <link>https://danysk.github.io/</link>
    <description>Recent content in HOME on Danilo Pianini</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>© Danilo Pianini</copyright>
    <lastBuildDate>Wed, 03 Aug 2022 19:25:30 +0200</lastBuildDate><atom:link href="https://danysk.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Answers to the QA comments in SE 2021/22</title>
      <link>https://danysk.github.io/post/2022-08-03-se-dtm/</link>
      <pubDate>Wed, 03 Aug 2022 19:25:30 +0200</pubDate>
      
      <guid>https://danysk.github.io/post/2022-08-03-se-dtm/</guid>
      <description>The University of Bologna asks students to anonymously fill questionaries on the quality of each course, whose answers are then visible to the teachers.
I personally believe that it is very important to provide textual feeback to the teacher (besides marking the very bad/bad/good/very good markers on the initial questions), as they can be used to improve the course. Since I stress my students to write them, the very least I can do is read and reply.</description>
    </item>
    
    <item>
      <title>Risposte ai questionari di LSS 2021/22</title>
      <link>https://danysk.github.io/post/2022-08-02-lss/</link>
      <pubDate>Tue, 02 Aug 2022 19:25:30 +0200</pubDate>
      
      <guid>https://danysk.github.io/post/2022-08-02-lss/</guid>
      <description>Per ogni corso, l&amp;rsquo;Università di Bologna richiede agli studenti di compilare dei questionari anonimi, i cui risultati sono poi visibili ai docenti.
Personalmente insisto sull&amp;rsquo;importanza di compilare (oltre allo spazio con le risposte sintetiche sul gradimento del corso) anche lo spazio con i commenti in testo libero, visto che scoccio per scriverli, mi prendo la briga di leggerli e rispondere. I commenti dovrebbero esserci tutti, tranne quelli con argomenti capiti meglio / peggio senza un chiaro contesto.</description>
    </item>
    
    <item>
      <title>Risposte ai questionari di OOP 2021/22</title>
      <link>https://danysk.github.io/post/2022-08-01-oop/</link>
      <pubDate>Mon, 01 Aug 2022 19:25:30 +0200</pubDate>
      
      <guid>https://danysk.github.io/post/2022-08-01-oop/</guid>
      <description>Per ogni corso, l&amp;rsquo;Università di Bologna richiede agli studenti di compilare dei questionari anonimi, i cui risultati sono poi visibili ai docenti.
Personalmente insisto sull&amp;rsquo;importanza di compilare (oltre allo spazio con le risposte sintetiche sul gradimento del corso) anche lo spazio con i commenti in testo libero, visto che scoccio per scriverli, mi prendo la briga di leggerli e rispondere. I commenti dovrebbero esserci tutti, tranne quelli con argomenti capiti meglio / peggio senza un chiaro contesto.</description>
    </item>
    
    <item>
      <title>Risposte ai questionari di LSS 2020/21</title>
      <link>https://danysk.github.io/post/2021-05-24-risposte-studenti-lss/</link>
      <pubDate>Mon, 24 May 2021 19:25:30 +0200</pubDate>
      
      <guid>https://danysk.github.io/post/2021-05-24-risposte-studenti-lss/</guid>
      <description>Per ogni corso, l&amp;rsquo;Università di Bologna richiede agli studenti di compilare dei questionari anonimi, i cui risultati sono poi visibili ai docenti.
Personalmente insisto sull&amp;rsquo;importanza di compilare (oltre allo spazio con le risposte sintetiche sul gradimento del corso) anche lo spazio con i commenti in testo libero.
In questo post, commento quelli dell&amp;rsquo; A.A. 2020/21, in didattica mista a causa del coronavirus.
Dovrei aver inserito tutti i commenti, ad eccezione di quelli non positivi riferiti direttamente ai tutor; ho girato loro i commenti sia positivi che negativi di modo che potessero leggerli, non mi sembra corretto aggiungere dettagli qui.</description>
    </item>
    
    <item>
      <title>Risposte ai questionari di OOP 2020/21</title>
      <link>https://danysk.github.io/post/2021-05-21-risposte-studenti/</link>
      <pubDate>Fri, 21 May 2021 19:25:30 +0200</pubDate>
      
      <guid>https://danysk.github.io/post/2021-05-21-risposte-studenti/</guid>
      <description>Per ogni corso, l&amp;rsquo;Università di Bologna richiede agli studenti di compilare dei questionari anonimi, i cui risultati sono poi visibili ai docenti.
Personalmente insisto sull&amp;rsquo;importanza di compilare (oltre allo spazio con le risposte sintetiche sul gradimento del corso) anche lo spazio con i commenti in testo libero.
In questo post, commento quelli dell&amp;rsquo; A.A. 2020/21, in didattica mista a causa del coronavirus.
Dovrei aver inserito tutti i commenti, ad eccezione di quelli non positivi riferiti direttamente ai tutor; ho girato loro i commenti sia positivi che negativi di modo che potessero leggerli, non mi sembra corretto aggiungere dettagli qui.</description>
    </item>
    
    <item>
      <title>Risposte ai questionari di OOP 2019/20</title>
      <link>https://danysk.github.io/post/2020-12-28-risposte-studenti/</link>
      <pubDate>Mon, 28 Dec 2020 19:25:30 +0200</pubDate>
      
      <guid>https://danysk.github.io/post/2020-12-28-risposte-studenti/</guid>
      <description>Per ogni corso, l&amp;rsquo;Università di Bologna richiede agli studenti di compilare dei questionari anonimi, i cui risultati sono poi visibili ai docenti.
Personalmente insisto sull&amp;rsquo;importanza di compilare (oltre allo spazio con le risposte sintetiche sul gradimento del corso) anche lo spazio con i commenti in testo libero.
In questo post, commento quelli di un anno fa (A.A. 2019/20), pre-coronavirus.
Dovrei aver inserito tutti i commenti, ad eccezione di quelli non positivi riferiti direttamente ai tutor; ho girato loro i commenti sia positivi che negativi di modo che potessero leggerli, non mi sembra corretto aggiungere dettagli qui.</description>
    </item>
    
    <item>
      <title>Comparing lambda expressions in four JVM-hosted languages</title>
      <link>https://danysk.github.io/post/2020-05-08-bibliography/</link>
      <pubDate>Fri, 08 May 2020 19:25:30 +0200</pubDate>
      
      <guid>https://danysk.github.io/post/2020-05-08-bibliography/</guid>
      <description>Preamble: understanding how science works This may sound surprising, but I learnt what a scientific paper actually was during my master degree, when&amp;hellip; well, when I published my first paper, basically. At least in my university, nobody cared spending time to explain us how the publication of scientific results worked, it is an information that somewhat boils up from the context, with the final result that for many bachelors there&amp;rsquo;s not much of a difference in reliability between an article on a blog and a paper published on a high level journal.</description>
    </item>
    
    <item>
      <title>Comparing lambda expressions in four JVM-hosted languages</title>
      <link>https://danysk.github.io/post/2018-01-31-lambda/</link>
      <pubDate>Wed, 31 Jan 2018 19:25:30 +0200</pubDate>
      
      <guid>https://danysk.github.io/post/2018-01-31-lambda/</guid>
      <description>In recent times, several languages targeting the JVM have been realized, and most of them with the goal of providing a hybrid functional / object oriented experience, that in Java has arrived only with Java 8, and it is not completely satisfactory.
Among those languages, Scala and Kotlin are those most common and used (although Groovy has received a great push from Gradle / Grails).
I used a little bit every one of them, and in this post I&amp;rsquo;d like to compare the syntax for a lambda function among Java (8+), Kotlin, Scala, and Xtend.</description>
    </item>
    
    <item>
      <title>A Higher-Order Calculus of Computational Fields</title>
      <link>https://danysk.github.io/portfolio/2019-tocl/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://danysk.github.io/portfolio/2019-tocl/</guid>
      <description>The complexity of large-scale distributed systems, particularly when deployed in physical space, calls for new mechanisms to address composability and reusability of collective adaptive behaviour. Computational fields have been proposed as an effective abstraction to fill the gap between the macro-level of such systems (specifying a system’s collective behaviour) and the micro-level (individual devices’ actions of computation and interaction to implement that collective specification), thereby providing a basis to better facilitate the engineering of collective APIs and complex systems at higher levels of abstraction.</description>
    </item>
    
    <item>
      <title>Aggregate Programming for the Internet of Things</title>
      <link>https://danysk.github.io/portfolio/2015-ieee-computer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://danysk.github.io/portfolio/2015-ieee-computer/</guid>
      <description>Through field calculus constructs and building-block APIs, aggregate programming could help unlock the IoT&amp;rsquo;s true potential by allowing complex distributed services to be specified succinctly and by enabling such services to be safely encapsulated, modulated, and composed with one another.</description>
    </item>
    
    <item>
      <title>Chemical-oriented simulation of computational systems with Alchemist</title>
      <link>https://danysk.github.io/portfolio/2019-jlamp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://danysk.github.io/portfolio/2019-jlamp/</guid>
      <description>In this paper we address the engineering of complex and emerging computational systems featuring situatedness, adaptivity and self-organisation, like pervasive computing applications in which humans and devices, dipped in a very mobile environment, opportunistically interact to provide and exploit information services. We adopt a meta-model in which possibly mobile, interconnected and communicating agents work according to a set of chemical-like laws. According to this view, substantiated by recent research on pervasive computing systems, we present the Alchemist simulation framework, which retains the performance of known Stochastic Simulation Algorithms for (bio)chemistry, though it is tailored to the specific features of complex and situated computational systems.</description>
    </item>
    
    <item>
      <title>Engineering Resilient Collective Adaptive Systems by Self-Stabilisation</title>
      <link>https://danysk.github.io/portfolio/2018-tomacs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://danysk.github.io/portfolio/2018-tomacs/</guid>
      <description>Collective adaptive systems are an emerging class of networked computational systems particularly suited for application domains such as smart cities, complex sensor networks, and the Internet of Things. These systems tend to feature large-scale, heterogeneity of communication model (including opportunistic peer-to-peer wireless interaction) and require inherent self-adaptiveness properties to address unforeseen changes in operating conditions. In this context, it is extremely difficult (if not seemingly intractable) to engineer reusable pieces of distributed behaviour to make them provably correct and smoothly composable.</description>
    </item>
    
    <item>
      <title>From distributed coordination to field calculus and aggregate computing</title>
      <link>https://danysk.github.io/portfolio/2013-jos-alchemist/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://danysk.github.io/portfolio/2013-jos-alchemist/</guid>
      <description>Aggregate computing is an emerging approach to the engineering of complex coordination for distributed systems, based on viewing system interactions in terms of information propagating through collectives of devices, rather than in terms of individual devices and their interaction with their peers and environment. The foundation of this approach is the distillation of a number of prior approaches, both formal and pragmatic, proposed under the umbrella of field-based coordination, and culminating into the field calculus, a universal functional programming model for the specification and composition of collective behaviours with equivalent local and aggregate semantics.</description>
    </item>
    
    <item>
      <title>Partitioned integration and coordination via the self-organising coordination regions pattern</title>
      <link>https://danysk.github.io/portfolio/2020-fgcs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://danysk.github.io/portfolio/2020-fgcs/</guid>
      <description>Highlights Self-organising Coordination Regions (SCR) is a design pattern for decentralised self-integration in dynamic environments. SCR captures recurrent design approaches in a variety of domains including swarm control, resource management, and service orchestration. SCR consists of a dynamic process involving leader election, coalition formation, and feedback loops between leaders and subordinates. SCR can be straightforwardly implemented as continuous collective workflows in Aggregate Programming languages. SCR is versatile, as shown through case studies in edge computing and hierarchical, heterogeneous networks.</description>
    </item>
    
    <item>
      <title>Protelis: Practical Aggregate Programming</title>
      <link>https://danysk.github.io/portfolio/2015-sac-protelis/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://danysk.github.io/portfolio/2015-sac-protelis/</guid>
      <description>The notion of a computational field has been proposed as a unifying abstraction for developing distributed systems, focusing on the computations and coordination of aggregates of devices instead of individual behavior. Prior field-based languages, however, have suffered from a number of practical limitations that have posed barriers to adoption and use. We address these limitations by introduction of Protelis, a functional language based on computational fields and embedded in Java, thereby enabling the construction of widely reusable components of aggregate systems.</description>
    </item>
    
    <item>
      <title>Self-Adaptation to Device Distribution in the Internet of Things</title>
      <link>https://danysk.github.io/portfolio/2017-taas/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://danysk.github.io/portfolio/2017-taas/</guid>
      <description>A key problem when coordinating the behaviour of spatially situated networks, like those typically found in the Internet of Things (IoT), is adaptation to changes impacting network topology, density, and heterogeneity. Computational goals for such systems, however, are often dependent on geometric properties of the continuous environment in which the devices are situated rather than the particulars of how devices happen to be distributed through it. In this article, we identify a new property of distributed algorithms, eventual consistency, which guarantees that computation converges to a final state that approximates a predictable limit, based on the continuous environment, as the density and speed of devices increases.</description>
    </item>
    
  </channel>
</rss>
